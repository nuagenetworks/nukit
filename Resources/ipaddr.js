// Generated by CoffeeScript 1.10.0
(function() {
  var expandIPv6, ipaddr, ipv4Part, ipv4Regexes, ipv6Part, ipv6Regexes, matchCIDR, root;

  ipaddr = {};

  root = this;

  if ((typeof module !== "undefined" && module !== null) && module.exports) {
    module.exports = ipaddr;
  } else {
    root['ipaddr'] = ipaddr;
  }

  matchCIDR = function(first, second, partSize, cidrBits) {
    var part, shift;
    if (first.length !== second.length) {
      throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
    }
    part = 0;
    while (cidrBits > 0) {
      shift = partSize - cidrBits;
      if (shift < 0) {
        shift = 0;
      }
      if (first[part] >> shift !== second[part] >> shift) {
        return false;
      }
      cidrBits -= partSize;
      part += 1;
    }
    return true;
  };

  ipaddr.subnetMatch = function(address, rangeList, defaultName) {
    var i, len, rangeName, rangeSubnets, subnet;
    if (defaultName == null) {
      defaultName = 'unicast';
    }
    for (rangeName in rangeList) {
      rangeSubnets = rangeList[rangeName];
      if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {
        rangeSubnets = [rangeSubnets];
      }
      for (i = 0, len = rangeSubnets.length; i < len; i++) {
        subnet = rangeSubnets[i];
        if (address.match.apply(address, subnet)) {
          return rangeName;
        }
      }
    }
    return defaultName;
  };

  ipaddr.IPv4 = (function() {
    function IPv4(octets) {
      var i, len, octet, tmp;
      if (octets.length !== 4) {
        throw new Error("ipaddr: ipv4 octet count should be 4");
      }
      for (i = 0, len = octets.length; i < len; i++) {
        octet = octets[i];
        if (!((0 <= octet && octet <= 255))) {
          throw new Error("ipaddr: ipv4 octet is a byte");
        }
      }
      this.octets = octets;
      this.ip = this.toString();
      tmp = 0;
      tmp |= parseInt(this.octets[0]) << 24;
      tmp |= parseInt(this.octets[1]) << 16;
      tmp |= parseInt(this.octets[2]) << 8;
      tmp |= parseInt(this.octets[3]);
      this.decimals = tmp >>> 0;
    }

    IPv4.prototype.kind = function() {
      return 'ipv4';
    };

    IPv4.prototype.toString = function() {
      return this.octets.join(".");
    };

    IPv4.prototype.toByteArray = function() {
      return this.octets.slice(0);
    };

    IPv4.prototype.match = function(other, cidrRange) {
      var ref;
      if (cidrRange === void 0) {
        ref = [other.address, other.netmask.bits], other = ref[0], cidrRange = ref[1];
      }
      if (other.kind() !== 'ipv4') {
        throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
      }
      return matchCIDR(this.octets, other.octets, 8, cidrRange);
    };

    IPv4.prototype.SpecialRanges = {
      unspecified: [[new IPv4([0, 0, 0, 0]), 8]],
      broadcast: [[new IPv4([255, 255, 255, 255]), 32]],
      multicast: [[new IPv4([224, 0, 0, 0]), 4]],
      linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],
      loopback: [[new IPv4([127, 0, 0, 0]), 8]],
      "private": [[new IPv4([10, 0, 0, 0]), 8], [new IPv4([172, 16, 0, 0]), 12], [new IPv4([192, 168, 0, 0]), 16]],
      reserved: [[new IPv4([192, 0, 0, 0]), 24], [new IPv4([192, 0, 2, 0]), 24], [new IPv4([192, 88, 99, 0]), 24], [new IPv4([198, 51, 100, 0]), 24], [new IPv4([203, 0, 113, 0]), 24], [new IPv4([240, 0, 0, 0]), 4]]
    };

    IPv4.prototype.range = function() {
      return ipaddr.subnetMatch(this, this.SpecialRanges);
    };

    IPv4.prototype.toIPv4MappedAddress = function() {
      return ipaddr.IPv6.parse("::ffff:" + (this.toString()));
    };

    return IPv4;

  })();

  ipaddr.IPv4Netmask = (function() {
    function IPv4Netmask(bits) {
      var netmasks;
      this.bits = parseInt(bits);
      netmasks = {
        0: 0,
        1: 2147483648,
        2: 3221225472,
        3: 3758096384,
        4: 4026531840,
        5: 4160749568,
        6: 4227858432,
        7: 4261412864,
        8: 4278190080,
        9: 4286578688,
        10: 4290772992,
        11: 4292870144,
        12: 4293918720,
        13: 4294443008,
        14: 4294705152,
        15: 4294836224,
        16: 4294901760,
        17: 4294934528,
        18: 4294950912,
        19: 4294959104,
        20: 4294963200,
        21: 4294965248,
        22: 4294966272,
        23: 4294966784,
        24: 4294967040,
        25: 4294967168,
        26: 4294967232,
        27: 4294967264,
        28: 4294967280,
        29: 4294967288,
        30: 4294967292,
        31: 4294967294,
        32: 4294967295
      };
      this.decimals = netmasks[this.bits];
      this.ip = this.decimalToString(this.decimals);
    }

    IPv4Netmask.prototype.decimalToString = function(netIpDec) {
      var first, fourth, second, third;
      first = (netIpDec >>> 24) & 255;
      second = (netIpDec >>> 16) & 255;
      third = (netIpDec >>> 8) & 255;
      fourth = netIpDec & 255;
      return first + "." + second + "." + third + "." + fourth;
    };

    return IPv4Netmask;

  })();

  ipv4Part = "(0?\\d+|0x[a-f0-9]+)";

  ipv4Regexes = {
    fourOctet: new RegExp("^" + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "$", 'i'),
    longValue: new RegExp("^" + ipv4Part + "$", 'i')
  };

  ipaddr.IPv4.parser = function(string) {
    var match, parseIntAuto, part, shift, value;
    parseIntAuto = function(string) {
      if (string[0] === "0" && string[1] !== "x") {
        return parseInt(string, 8);
      } else {
        return parseInt(string);
      }
    };
    if (match = string.match(ipv4Regexes.fourOctet)) {
      return (function() {
        var i, len, ref, results;
        ref = match.slice(1, 6);
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          part = ref[i];
          results.push(parseIntAuto(part));
        }
        return results;
      })();
    } else if (match = string.match(ipv4Regexes.longValue)) {
      value = parseIntAuto(match[1]);
      if (value > 0xffffffff || value < 0) {
        throw new Error("ipaddr: address outside defined range");
      }
      return ((function() {
        var i, results;
        results = [];
        for (shift = i = 0; i <= 24; shift = i += 8) {
          results.push((value >> shift) & 0xff);
        }
        return results;
      })()).reverse();
    } else {
      return null;
    }
  };

  ipaddr.IPv4.netmaskParser = function(string) {
    return new ipaddr.IPv4Netmask(parseInt(string));
  };

  ipaddr.IPv6 = (function() {
    function IPv6(parts) {
      var i, len, part, tmp;
      if (parts.length !== 8) {
        throw new Error("ipaddr: ipv6 part count should be 8");
      }
      for (i = 0, len = parts.length; i < len; i++) {
        part = parts[i];
        if (!((0 <= part && part <= 0xffff))) {
          throw new Error("ipaddr: ipv6 part should fit to two octets");
        }
      }
      this.parts = parts;
      this.ip = this.toString();
      tmp = 0;
      tmp |= parseInt(this.parts[0]) << 112;
      tmp |= parseInt(this.parts[1]) << 96;
      tmp |= parseInt(this.parts[2]) << 80;
      tmp |= parseInt(this.parts[3]) << 64;
      tmp |= parseInt(this.parts[4]) << 48;
      tmp |= parseInt(this.parts[5]) << 32;
      tmp |= parseInt(this.parts[6]) << 16;
      tmp |= parseInt(this.parts[7]);
      this.decimals = tmp >>> 0;
    }

    IPv6.prototype.kind = function() {
      return 'ipv6';
    };

    IPv6.prototype.toString = function() {
      var compactStringParts, i, len, part, pushPart, state, stringParts;
      stringParts = (function() {
        var i, len, ref, results;
        ref = this.parts;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          part = ref[i];
          results.push(part.toString(16));
        }
        return results;
      }).call(this);
      compactStringParts = [];
      pushPart = function(part) {
        return compactStringParts.push(part);
      };
      state = 0;
      for (i = 0, len = stringParts.length; i < len; i++) {
        part = stringParts[i];
        switch (state) {
          case 0:
            if (part === '0') {
              pushPart('');
            } else {
              pushPart(part);
            }
            state = 1;
            break;
          case 1:
            if (part === '0') {
              state = 2;
            } else {
              pushPart(part);
            }
            break;
          case 2:
            if (part !== '0') {
              pushPart('');
              pushPart(part);
              state = 3;
            }
            break;
          case 3:
            pushPart(part);
        }
      }
      if (state === 2) {
        pushPart('');
        pushPart('');
      }
      return compactStringParts.join(":");
    };

    IPv6.prototype.toByteArray = function() {
      var bytes, i, len, part, ref;
      bytes = [];
      ref = this.parts;
      for (i = 0, len = ref.length; i < len; i++) {
        part = ref[i];
        bytes.push(part >> 8);
        bytes.push(part & 0xff);
      }
      return bytes;
    };

    IPv6.prototype.toNormalizedString = function() {
      var part;
      return ((function() {
        var i, len, ref, results;
        ref = this.parts;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          part = ref[i];
          results.push(part.toString(16));
        }
        return results;
      }).call(this)).join(":");
    };

    IPv6.prototype.match = function(other, cidrRange) {
      var ref;
      if (cidrRange === void 0) {
        ref = [other.address, other.netmask.bits], other = ref[0], cidrRange = ref[1];
      }
      if (other.kind() !== 'ipv6') {
        throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
      }
      return matchCIDR(this.parts, other.parts, 16, cidrRange);
    };

    IPv6.prototype.SpecialRanges = {
      unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],
      linkLocal: [new IPv6([0xfe80, 0, 0, 0, 0, 0, 0, 0]), 10],
      multicast: [new IPv6([0xff00, 0, 0, 0, 0, 0, 0, 0]), 8],
      loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],
      uniqueLocal: [new IPv6([0xfc00, 0, 0, 0, 0, 0, 0, 0]), 7],
      ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 0xffff, 0, 0]), 96],
      rfc6145: [new IPv6([0, 0, 0, 0, 0xffff, 0, 0, 0]), 96],
      rfc6052: [new IPv6([0x64, 0xff9b, 0, 0, 0, 0, 0, 0]), 96],
      '6to4': [new IPv6([0x2002, 0, 0, 0, 0, 0, 0, 0]), 16],
      teredo: [new IPv6([0x2001, 0, 0, 0, 0, 0, 0, 0]), 32],
      reserved: [[new IPv6([0x2001, 0xdb8, 0, 0, 0, 0, 0, 0]), 32]]
    };

    IPv6.prototype.range = function() {
      return ipaddr.subnetMatch(this, this.SpecialRanges);
    };

    IPv6.prototype.isIPv4MappedAddress = function() {
      return this.range() === 'ipv4Mapped';
    };

    IPv6.prototype.toIPv4Address = function() {
      var high, low, ref;
      if (!this.isIPv4MappedAddress()) {
        throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
      }
      ref = this.parts.slice(-2), high = ref[0], low = ref[1];
      return new ipaddr.IPv4([high >> 8, high & 0xff, low >> 8, low & 0xff]);
    };

    return IPv6;

  })();

  ipaddr.IPv6Netmask = (function() {
    function IPv6Netmask(bits) {
      this.bits = parseInt(bits);
    }

    return IPv6Netmask;

  })();

  ipaddr.IPv4CIDR = (function() {
    function IPv4CIDR(address, netmask) {
      var netIpDec;
      this.address = address;
      this.netmask = netmask;
      netIpDec = (this.address.decimals & this.netmask.decimals) >>> 0;
      this.IPNumber = 0xFFFFFFFF - 1 - this.netmask.decimals;
      if (this.IPNumber === -1 || this.IPNumber === 0) {
        if (this.IPNumber === -1) {
          this.IPNumber = 1;
          this.lastIP = this.firstIP = this.decimalToString(netIpDec);
        } else {
          this.IPNumber = 2;
          this.firstIP = this.decimalToString(netIpDec);
          this.lastIP = this.decimalToString(netIpDec + 1);
        }
      } else {
        this.firstIP = this.decimalToString(netIpDec + 1);
        this.lastIP = this.decimalToString(netIpDec + this.IPNumber);
      }
    }

    IPv4CIDR.prototype.kind = function() {
      return 'ipv4cidr';
    };

    IPv4CIDR.prototype.decimalToString = function(netIpDec) {
      var first, fourth, second, third;
      first = (netIpDec >>> 24) & 255;
      second = (netIpDec >>> 16) & 255;
      third = (netIpDec >>> 8) & 255;
      fourth = netIpDec & 255;
      return first + "." + second + "." + third + "." + fourth;
    };

    return IPv4CIDR;

  })();

  ipaddr.IPv6CIDR = (function() {
    function IPv6CIDR(address, netmask) {
      this.address = address;
      this.netmask = netmask;
    }

    IPv6CIDR.prototype.kind = function() {
      return 'ipv6cidr';
    };

    return IPv6CIDR;

  })();

  ipv6Part = "(?:[0-9a-f]+::?)+";

  ipv6Regexes = {
    "native": new RegExp("^(::)?(" + ipv6Part + ")?([0-9a-f]+)?(::)?$", 'i'),
    transitional: new RegExp(("^((?:" + ipv6Part + ")|(?:::)(?:" + ipv6Part + ")?)") + (ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "$"), 'i')
  };

  expandIPv6 = function(string, parts) {
    var colonCount, lastColon, part, replacement, replacementCount;
    if (string.indexOf('::') !== string.lastIndexOf('::')) {
      return null;
    }
    colonCount = 0;
    lastColon = -1;
    while ((lastColon = string.indexOf(':', lastColon + 1)) >= 0) {
      colonCount++;
    }
    if (string.substr(0, 2) === '::') {
      colonCount--;
    }
    if (string.substr(-2, 2) === '::') {
      colonCount--;
    }
    if (colonCount > parts) {
      return null;
    }
    replacementCount = parts - colonCount;
    replacement = ':';
    while (replacementCount--) {
      replacement += '0:';
    }
    string = string.replace('::', replacement);
    if (string[0] === ':') {
      string = string.slice(1);
    }
    if (string[string.length - 1] === ':') {
      string = string.slice(0, -1);
    }
    return (function() {
      var i, len, ref, results;
      ref = string.split(":");
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        part = ref[i];
        results.push(parseInt(part, 16));
      }
      return results;
    })();
  };

  ipaddr.IPv6.parser = function(string) {
    var match, parts;
    if (string.match(ipv6Regexes['native'])) {
      return expandIPv6(string, 8);
    } else if (match = string.match(ipv6Regexes['transitional'])) {
      parts = expandIPv6(match[1].slice(0, -1), 6);
      if (parts) {
        parts.push(parseInt(match[2]) << 8 | parseInt(match[3]));
        parts.push(parseInt(match[4]) << 8 | parseInt(match[5]));
        return parts;
      }
    }
    return null;
  };

  ipaddr.IPv6.netmaskParser = function(string) {
    return new ipaddr.IPv6Netmask(parseInt(string));
  };

  ipaddr.IPv4.isIPv4 = ipaddr.IPv6.isIPv6 = function(string) {
    return this.parser(string) !== null;
  };

  ipaddr.IPv4.isValid = function(string) {
    var e, error;
    try {
      new this(this.parser(string));
      return true;
    } catch (error) {
      e = error;
      return false;
    }
  };

  ipaddr.IPv6.isValid = function(string) {
    var e, error;
    if (!string || string.indexOf(":") === -1) {
      return false;
    }
    try {
      new this(this.parser(string));
      return true;
    } catch (error) {
      e = error;
      return false;
    }
  };

  ipaddr.IPv4.parse = ipaddr.IPv6.parse = function(string) {
    var parts;
    parts = this.parser(string);
    if (parts === null) {
      throw new Error("ipaddr: string is not formatted like ip address");
    }
    return new this(parts);
  };

  ipaddr.IPv4.parseNetmask = ipaddr.IPv6.parseNetmask = function(string) {
    return this.netmaskParser(string);
  };

  ipaddr.IPv4.parseCIDR = function(string) {
    var address, decimals, match, netmask, octets, reverseNetmasks, tmp;
    if (match = string.match(/^(.+)\/(\d+)$/)) {
      address = this.parse(match[1]);
      netmask = this.parseNetmask(match[2]);
      return new ipaddr.IPv4CIDR(address, netmask);
    }
    if (match = string.match(/^(.+)\/(.+)$/)) {
      address = this.parse(match[1]);
      octets = match[2].split('.');
      tmp = 0;
      tmp |= parseInt(octets[0]) << 24;
      tmp |= parseInt(octets[1]) << 16;
      tmp |= parseInt(octets[2]) << 8;
      tmp |= parseInt(octets[3]);
      decimals = tmp >>> 0;
      reverseNetmasks = {
        0: 0,
        2147483648: 1,
        3221225472: 2,
        3758096384: 3,
        4026531840: 4,
        4160749568: 5,
        4227858432: 6,
        4261412864: 7,
        4278190080: 8,
        4286578688: 9,
        4290772992: 10,
        4292870144: 11,
        4293918720: 12,
        4294443008: 13,
        4294705152: 14,
        4294836224: 15,
        4294901760: 16,
        4294934528: 17,
        4294950912: 18,
        4294959104: 19,
        4294963200: 20,
        4294965248: 21,
        4294966272: 22,
        4294966784: 23,
        4294967040: 24,
        4294967168: 25,
        4294967232: 26,
        4294967264: 27,
        4294967280: 28,
        4294967288: 29,
        4294967292: 30,
        4294967294: 31,
        4294967295: 32
      };
      netmask = this.parseNetmask(reverseNetmasks[decimals]);
      return new ipaddr.IPv4CIDR(address, netmask);
    }
    throw new Error("ipaddr: string is not formatted like a CIDR range");
  };

  ipaddr.IPv6.parseCIDR = function(string) {
    var address, match, netmask;
    if (match = string.match(/^(.+)\/(\d+)$/)) {
      address = this.parse(match[1]);
      netmask = this.parseNetmask(match[2]);
      return new ipaddr.IPv6CIDR(address, netmask);
    }
    throw new Error("ipaddr: string is not formatted like a CIDR range");
  };

  ipaddr.isValid = function(string) {
    return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);
  };

  ipaddr.parse = function(string) {
    if (ipaddr.IPv6.isValid(string)) {
      return ipaddr.IPv6.parse(string);
    } else if (ipaddr.IPv4.isValid(string)) {
      return ipaddr.IPv4.parse(string);
    } else {
      throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
    }
  };

  ipaddr.parseCIDR = function(string) {
    var e, error, error1;
    try {
      return ipaddr.IPv6.parseCIDR(string);
    } catch (error) {
      e = error;
      try {
        return ipaddr.IPv4.parseCIDR(string);
      } catch (error1) {
        e = error1;
        throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR");
      }
    }
  };

  ipaddr.process = function(string) {
    var addr;
    addr = this.parse(string);
    if (addr.kind() === 'ipv6' && addr.isIPv4MappedAddress()) {
      return addr.toIPv4Address();
    } else {
      return addr;
    }
  };

}).call(this);
